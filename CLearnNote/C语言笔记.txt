C语言开发需要1.文本编辑器（noptepad，sublime，vim）	2.C编译器 GNU C / C ++编译器

1.逻辑运算符和位运算符。
	&，| 按位与，按位或。

2.extern 关键字
	在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。
	说白了就是告诉编译器L:我要用该变量或函数，但是我这个文件里没有定义，你去其他文件可以找到。

3.#include 的用法
	#include叫做“文件包含”。它的功能是用来指定文件的全部内容替换程序中的命令行，从而使指定的文件与当前源文件连成一个源文件。 

		有如下两种形式：
		#include "文件名"
		#include <文件名>

		使用尖括号：表示编译系统根据系统头文件存放的目录路径去搜索系统头文件，而不是在源文件目录去查找； 
		使用双引号：表示编译系统首先在当前的源文件目录中查找，若未找到才根据系统的头文件存放的目录路径去搜索系统头文件。
4.rand() 产生随机数
	rand()根据一个随即种子进行产生随机数。每次系统启动后种子不会变。但可以调用srand(int a)函数设置该种子。
	time()获取从某个计算机时间点后的描述。所以每次种子都是在变的。

5.static 关键字		https://blog.csdn.net/keyeagle/article/details/6708077	
					https://blog.csdn.net/y780465649/article/details/52155641/

	static修饰局部变量时该变量是存放在静态存储区，生命周期是整个程序结束。
	类似于C++中的private，别人无法访问，其他文件想访问，只能通过调用他的方法来访问static修饰的变量。

	static局部变量初次定义时就要初始化，且只能初始化一次。如果在定义的时候不初始化，编译器就会自动赋值为0；（也就是说如果重复调用同一个函数，在第二次调用时，就不会再执行static局部变量初始化那句话 了）
	特点: static局部变量的”记忆性”与生存期的”全局性”
	所谓”记忆性”是指在两次函数调用时, 在第二次调用进入时, 能保持第一次调用退出时的值.

	5.1 static修饰全局变量，存储在全局变量区（.data或.bss段）。只能在定义它的源文件中有效，其他源文件无法访问。（可以防止不同人写一个程序时，函数重名导致的一些问题。）
	5.2	static修饰局部变量，存储在全局变量区（只在.data段）。所以虽然是局部变量，但是生存周期为整个程序。只能被其作用域内的函数或变量访问。如若没初始化，系统自动初始化为0.每次调用都是上次调用结束后的值。
	5.3 static修饰函数。如：提供一个接口函数cal919()，实现该接口的为919mac()；可对919mac()进行static，保护该函数。
	 static函数可以很好地解决不同原文件中函数同名的问题，因为一个源文件对于其他源文件中的static函数是不可见的。

	5.5 static修饰的对象，只能在本文件中后面的位置使用。
	5.6 static对象，如果是全局变量，存储在对应的.data段（已初始化）或.bss段(未初始化)；
		如果是局部变量，程序未进行初始化时，系统会自动初始化。系统会将他存在.data区。
			所以生命周期会与进程相同。
			且只可被作用域内的变量访问。因为是static，所以不能被其他函数和源文件访问
			未被初始化，则系统初始化为0。每次再调用此变量时，由于存在.data段，未被销毁，所以值不会重新初始化。
		static 局部变量时，可用于统计函数调用次数


6.递归可以决定打印的先后顺序，是进入栈时打印还是离开栈时打印

7.枚举
	枚举变量中的枚举元素系统是依照常量来处理的。故叫枚举常量
	枚举主要用于作为标识。赋值时有技巧性。

8.二维数组的传参。
	main()
	{
		int map[3][3] ={0};
		print_map(map);
	}

	void print_map(int (map)[3][3])
	{
		for()
			for()
				printf();

		map[0][0] = 2222;  // 此处改动map的值是对main里的map进行改动。


	}

9.getchar()函数。
	9.1 用户输入字符串str："a" 或者 "abc"，再输出回车表示输入完毕。系统收到回车后将字符串str以及换行符\n放入键盘缓冲区，getchar()会提取缓冲区第一个字符。等到下一次调用getchar()时再获取下一个字符。知道把\n获取出来后结束。如果还在循环使用getchar()，则再次阻塞等待输入。



10. 标准I/O流 STDIN STDOUT STDERR
	
11. umask(0);		https://blog.csdn.net/lina_acm/article/details/51880617
	linux中的 umask 函数主要用于：在创建新文件或目录时 屏蔽掉新文件或目录不应有的访问允许权限其实这个函数的作用，就是设置允许
当前进程创建文件或者目录最大可操作的权限，比如这里设置为0，它的意思就是0取反再创建文件时权限相与，也就是：(~0)&mode等于八进制的值0777 &  mode了，这样就是给后面的代码调用函数mkdir给出最大的权限，避免了创建目录或文件的权限不确定性。7=4+2+1。
	umask与chmod正好相反。chmod 777 就等于umask0

12.exit函数  https://www.cnblogs.com/noble/p/4144166.html
  return是语言级别的，它表示了调用堆栈的返回。而exit是系统调用级别的，它表示了一个进程的结束。	
  就是说C里面用return。linux系统用exit。
  非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。
   return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出，非0 为非正常退出



13 signal();
	给定一个信号，给出信号处理函数。

14.chdir 是C语言中的一个系统调用函数（同cd），用于改变当前工作目录，其参数为Path 目标目录，可以是绝对目录或相对目录	

15. 获取当前时间
	1.首先获取当前的时间对于1970年（UNIX纪元开始）的秒值。	gettimeofday(&tv,NULL).		
	struct timeval
	{
		long tv_sec;
		long tv_usec;
	}
	int64_t nSecond = (tv_sec*1000000 + tv_usec)/1000000 
	2.然后调用gtime_r(&nSecond,&tm_time);
	将时间存在tm结构体
	struct tm
	{
	     int    tm_sec;
	     int    tm_min;
	     int    tm_hour;
	     int    tm_mday;
	     int    tm_mon;				//月份比较特殊，其他都是正常的，月份是从0-11.代表1月到12月
	     int    tm_year;
	     int    tm_wday;
	     int    tm_yday;
	     int    tm_isdst;
	};


16.进程ID函数
	1.getpid() 获取当前进程的id。返回值为pid，一般会用来作为创建临时文件，避免临时文件相同带来的问题。
	 getppid() 获取父进程id
	 getpgid(pid_t pid)	获取指定进行的进程组id
	 getpgrp()获取当前进程的进程组id
	 setpgrp()设置当前进程为进程组的首进程

17.字符串操作类函数	
	1.strrchr(const char *str, char c);
		在str中找到末次字符C，返回C及其后面的字符串。如无，返回NULL。

18.readlink("/proc/self/exe",pathbuf,bufsie)获取当前进程执行路径。
	int execl(const char *path, const char *arg, ...);
		第一个参数为执行文件的路径路径，其余的参数传递给文件使用，最后一个参数必须为NULL
		只有失败的时候才会有返回值，返回-1. 所以成功的话，主进程不再执行后面的代码，而是执行新的path程序，并且当新程序结束时，主进程也会结束。且新的path进程会继承主进程的进程号，且不识别带~的路径

19.可变参数函数的定义。bts代码的writeBootLog里有样例。
	https://blog.csdn.net/qq_37824129/article/details/78763286
	 va_list list;  						用于指向可变的参数
     va_start(list, format);				指向可变的参数，即确定参数的下一个地址
     vsnprintf(buf, 4069, format, list);	把format和可变参数合并为一个参数
     va_end(list);							list指向0

20. 宏定义	
	#define JINGO(e) e
	#define	JINGI(e) #e
	#define JINGII(e,p)  p##e
	#用来把参数转换成字符串，##则用来连接两个前后两个参数，把它们变成一个参数

21.关于&0XFF
	byte类型的数字要&0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。byte转成int时，保证高位字节为0

22.逗号表达式
	(a+c,b+d,print()..)
	取最后一个表达式为整体表达式的值，并且对所有表达式都进行的运行（不管是赋值语句，还是计算，还是函数，都会先执行）
	所以(SystemAssert(#e,__FILE__,__LINE__),0)就等同于0，并且执行了前面的函数。
	比较：逗号表达式和||表达式  (void)((e) || (SystemAssert(#e,__FILE__,__LINE__),0))
		逗号表达式是讲所有的表达式进行运算判断后，取最后一个作为整体的值。
		||表达式是先判断第一个表达式是否为真，为真（非空且非0）则取1。并且不进行后面的判断（即运算）。否则判断后面的表达式（会执行）

23.calloc()  http://www.cnblogs.com/lidabo/p/4611411.html
	动态申请内存空间，并且初始化为0.其中整形初始化为0，指针初始化为NULL，实数据则是初始化为浮点型的0
	void* calloc (size_t num, size_t size);  num表示申请的个数，size表示每个申请的大小。
	1.void *malloc(int size); 
		分配size个字节的内存块，返回未确定类型的指针。C/C++规定，void* 类型可以强转成任何其他类型指针。失败返回null
	2.对于一个新定义的指针，总要有一个地址赋给这个指针，才能对指针进行操作。或是malloc申请的一个地址，或是一个已存的栈地址&i




24.sizeof(P) 代表指针大小，一般为8.	sizeof(*P)代表指针P的数据类型的大小，如果为结构体需要对齐。
	sizeof(char) 1  sizeof(char *) 为8
	sizeof(int) 4	sizeof(int *)位8


25.%[] 一个字符集 

26. 指针的大小比较就是指针的值大小的比较，也就是指向的地址值的大小比较

27.int sscanf( string str, string fmt, mixed var1, mixed var2 ... )
	从一个字符串中读进与指定格式相符的数据，返回成功赋值参数的个数。
	%[^a] 匹配非a的任意字符，贪婪性

28.整形提升	https://www.cnblogs.com/jianghg/p/4417190.html
	一旦对char进行操作，会整形提升到int。
	如：
	char a,b,c; c= a+b;
	sizeof(c) == 1, sizeof(a+b) == 4
	或者如：
	char a = 9;
	char b = a << 4;
	printf("%x\n",a<<4); 打印的是90
	printf("%x\n",b);	 打印的是ffffff90
	这是因为对char型变量进行%x时，会有整形提升的。并且提升时前补的值与b的最高位一致。即负数的话，前补1，正数前补0



29：代码开发时，对于宏定义采用互斥定义可以更便于判断。


30.全局变量  
	1.全局变量可以定义在一个.c文件中，变量存储在静态存储区，变量可以被其他文件中的函数使用，变量的作用范围是整个程序，全局变量可以再被使用过的地方改变数值。
	2.当定义了全局变量的时候，在其他.c文件中使用的时候需要加上extern前缀以声明是来自来自外部的外部变量；
	3.在main函数中定义的不叫全局变量，而extern的功能是声明定义在其他文件中的变量，而不是声明定义在其他函数中的变量。


31 errno 	https://www.cnblogs.com/Jimmy1988/p/7485133.html   宏定义详解
	对于recv时，如果server超时，那么errno会被赋值为  #define EAGAIN      11  /* Try again */
	所以一般EGAIN是对于超时的错误码

32  子进程退出时的signal的状态。  https://blog.csdn.net/melody_1016/article/details/84959962  宏定义详解
	vim /usr/include/bits/signum.h  中也有宏定义
	kill -l 也可以查看
	一般造成进程停止的信号为1,2,3,9,15  SIGHUP SIGINT SIGQUIT SIGKILL SIGTERM


33.fcntl函数		https://www.cnblogs.com/zxc2man/p/7649240.html
	fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性


34.https://blog.csdn.net/zhangzhi123456789/article/details/49133325	
	typedef int (*AcceptHook)(int , void );
		定义一个数据类型AcceptHook，该数据类型为函数指针型（int*也是数据类型），使用时需创建对象。
	int (*AcceptHook)(int , void );
		定义了一个函数指针,指针别名为AcceptHook。只能指向int ()(int ,void)类型的函数
		对比 int * p，定义整形值指针，指针别名为p。通过P表明为整形值指针。


35. 在线程函数的定义中，一定要将参数进行强转成需要用的数据类型。
1.不用临时变量交换两个数的值。  -- 利用异或（XOR）的性质
	(a XOR b) XOR a = b 
	此时a，b地址不可相同。否则在a ^ b时，a成0，b也会成0 在 ^a 的时候，还是会为0
	XOR的运算法则：同性为假，异性为真。（可理解为同性互斥，异性相吸）
	0 ^ 1 = 1
	1 ^ 0 = 1
	1 ^ 1 = 0
	0 ^ 0 = 0

	所以：
	0 ^ a = a;
	1 ^ a = !a;

	a^b = b^a
	a^b^c = (a^b)^c = a^(b^c)


	所以a^b^a = a^(b^a) = a^(a^b) = (a^a)^b = 0 ^ b = b

	void swap(int *a, int *b)
	{
		*a = *a^*b;
		*b = *a^*b;
		*a = *a^*b;
	}

2. 在线程函数的定义中，一定要将参数进行强转成需要用的数据类型。
	2.1 开辟的线程中的变量，和主线程的变量共同变化（共享）。
		即：内核在时间片轮转到线程n时，线程n若是对变量进行改动，即内存中有变动。则轮转到其他线程时，再读取该变量时也是改动后的结果



36.占位符	https://blog.csdn.net/qq_29874741/article/details/80320615 printf打印指定长度字符串
	 输出指定长度的字符串, 源字符串超长时截断, 不足时左对齐是:
    printf("%-N.Ms", str);          --N 为最终的字符串输出长度
                                    --M 为从参数字符串中取出的子串长度


37 如何理解指针
	普通的指针就是普通的文件的快捷方式，如TXT,XLS,DOSC等。结构体指针就是文件夹，指向一个代码块。



38 所谓的16进制字符串就是指16进制数表示的ASCII码字符。所以 0x30 = 48 = 字符0



39. 迭代与递归的差距		https://blog.csdn.net/liuchaoxuan/article/details/79967578


40.puts 和 fputs
	int fputs(char* str,FILE* fp);
	将字符串输出到指定文件，字符串结束标志'\0’不写入。 当fp为stdout时就是输出到终端。

41.fork函数
	1.fork是复制父进程的task_struct结构体，并修改部分结构体成员（如进程号，CPU等），并申请新的堆空间
	子进程刚开始，内核并没有为它分配物理内存，而是以只读的方式共享父进程内存，只有当子进程写时，才复制。即“copy-on-write”
	
	2.fork为什么会有两个返回值？https://www.cnblogs.com/hongzg1982/articles/2152093.html 	EAX寄存器
	
	3.fork后，父进程创建的变量i，子进程中用到时，地址是同一个（不可能一个变量名有两个地址）。为什么子进程对变量i进行修改，父进程里无效？
	https://www.cnblogs.com/big-devil/p/8590228.html
	如4G内存会被分为两部分：0~3G，是用户空间；3~4G是内核空间。用户进程只能访问用户地址，用户进程有自己的页表。
	在内核空间中又有虚拟地址和物理地址。父子进程里的变量，用户进行访问时，只能看到虚拟地址，这个是一样的，但是其映射到的物理地址不同。所以会看到地址相同，但是父子进程的变量不互相影响。



42 char *p = "\u0001";
	会报错，如何保存并向一个进程发送"\u0001"

43.https://www.jianshu.com/p/36ec7a047f29 原码反码补码的计算
	1.加减除
	计算机为了简便，用加法实现减法。
	对于8bit来说129 = 2 ，像圆是360°，365°=5°
	所以加减时，若最高位符号位溢出后，则舍去溢出的位（即舍去一个周期），依然只有8位
	当然32位同理
	[X+Y]的补码 = [X]的补码 + [Y]的补码 
	猜测：整出与求余，可以用减法来实现。

	2.乘除法
	乘法与十进制乘法大体一致，只需将右移多出的位去除。
	除法也与十进制除法相似


	小数的二进制表示https://blog.csdn.net/weixin_41042404/article/details/81276782
	比如0.5   0.5*2 = 1.0 所以为0000.1000
	0.75  0.75*2 = 1.5 取小数点后第一位为1，0.5*2 = 1.0 取小数点第二位为1. 所以为是0000.1100


44.scanf 接受空格	https://blog.csdn.net/chuhe163/article/details/81048751
	scanf("%[^\n]")



45./* 产生SIGSEGV,强制退出 */
    *((char*)-1) = 'x';
    1.为什么是'x',不是"x"。
    *进行了取值操作，所以此时左式为整形值（char为1个字节的integer），右式也应为整形，而不是地址char*
    *((char *)-1) = "x" 编译时警告，((char *)-1) = "x"编译时报错，为啥？？？
    2.为什么是-1。char*-1发生了哪些位操作。
    符号拓展（常见）与零拓展，是指小转大时，由于机器的不同对符号位进行的不同操作。类似移位运算的左补全。切记，位运算需要转成补码进行。所以小转大时数据不变（可以自己计算）。
    使用1的时候也段错误。但是char本性是字符。在ascii表里的字符对应十进制整形值都为非负数。所以用-1更有效。
    3.*((int*)-1) = 0是否可以。
    显然也是可以的，与char*同理，对整形常量强转为指针常量，再对指针常量的值进行改变，修改只读内存。但是char*的操作明显更简洁，占用资源最少。

  --符号位拓展，符号位缩减，零拓展https://blog.csdn.net/yjk13703623757/article/details/78084491
    小转大时，直接忽略高位，取地位。所以可能会出现转完后数据错误。同事转完后的最高位是否作为符号位，看转后的数据类型是不是unsigned（经过Ubuntu测试得出）

    %d（默认int）,%ld,&u（默认unsigned int）%c(默认char) 等占位符，会对占位对象进行数据转换。

46.uint8_t i = 0;	其二进制为0000 0000  对应的ascii码是 null
	uint8_t c = '0'; 其二进制为0011 0000 对应的ascii码是 字符0，对应十进制为48

47.关于堆栈的大小设置对于数组空间申请的限制
https://blog.csdn.net/qq_21882325/article/details/65445810
	ulimit -a 可以查看到数据区（DATA SEGMENT）和栈区（stack）的大小配置
	如果是局部变量的话和函数的话，是存储在stack里，此时Ubuntu中设置的为8192kb
	也就是8388608bytes，int数组的话只能存的下2097152 即200万大小的int数组。超出就会段错误

	ulimit -s 可以修改栈stack的大小

48.stack smashing detected
	当存在数组越界访问时，不会直接在访问的那一行报错，而是在函数return的时候报错，所以gdb调试bt时永远是在return那行。此时需要详细察看哪个数组存在越界行为。


49.https://blog.csdn.net/Sun19910114/article/details/47949629?utm_source=blogxgwz7 
	局部变量return时，可返回数据，无法返回地址。
局部函数得return 之所以可以返回局部变量。是因为系统会把局部变量的数据存在eax寄存器中，然后再从寄存器中取出来赋值给调用者

50.隐式声明函数，默认为int类型的函数
	所以一般在使用函数前，都要int func()，来声明函数的数据类型


51.register 变量 会将数据放在寄存器中，即不在内存中，不能&。长度一般不大于整形值，即不可float
			如果变量并不是频繁使用，放入寄存器中反而会影响效率
			寄存器理解为中转站，负责将内存传给CPU，再将CPU结果返回给内存。（皇帝-太监-大臣）。类似于缓存

52. 变量名相同的案例
int main()
	{
	   	int i = 0;

	    if(1){
	        char i = 'd';
	        printf("%c\n",i);
	    }

	   return 0;
	}
此例会输出d。因为第二个i在一个{}代码段里，所以可以如此定义，但最好不这样。以防混乱。

53.char * func(), c;
	此处func是一个指针函数。而c是个字符变量，不是字符指针。
	即 = char (* func() ), c
	  != char *(func(), c)

54.指针相关
	前景：i++ 与++i 的区别
	首先对于i++的实现是：  需要用到i增加前的值，并且需要i+1，所以要有临时变量
             int   temp;  
             temp   =   i;  
             i   =   i+1;  
             return   temp;  
	而++i的实现是：  只用i+1后的值，所以可以直接i=i+1；所以此法效率也更高，在不关心i之前的值时。
              i   =   i+1;  
              return   i;              
    由此可见，i++返回的是一个临时值，然后用到这个临时值，并将i+1。没有地址。
    		 ++i返回的值i的地址。因为是对i+1后的值进行操作，所以无需临时变量。

	1.赋值顺序不同。 i++是先赋值，后++，++i是先++，后赋值。所以i++返回原来的值，++i返回++后的值
	2.i++不能作为左值，++i可以。

	1.*p++ 不同于 (*p)++;
		*p++ 等价于 *p,p++;
		可以进行*p++ = val;
		代表先取*p的值，改成value，再对p++；
	   而(*P)++ 等价于(*p) = (*p)+1;
	   (*p)++ = val会报错：lvalue required as left operand of assignment。

	2. *++p 
	  等价于：p = p+1, *p;

	  对于*++p = value；
	  先p = p+1, *p=value;

	  当char *p, char *p = "123"; 时，此时p的值，即指向的地址实际为null。

55.char *p; 只生命未赋值，此时指向为空，不可以进行strcpy操作。需要先指向一个地址malloc，记得free


56.任何类型的指针都可以转成void *型，并且再转回原型时，不会丢失任何信息


57.const int *pi 和 int const *pi 和 int * const pi  以及 const  int * const pi
	虽然四种声明，但是只有三个结果。看什么？看const修饰后面的是什么
	const 修饰*pi 那么*pi 为 read-only，即不可以修改*pi的值
	const 修饰 pi,那么pi 为 read-only， 即不可以修改pi的值。

58.复杂的声明。
	1.char *(* test[10])(int p)
		·先找名字test
		·test被()包围，先处理()内部
		·test[10]  test是个数组，包含10个XXX元素。
		·* test[10] test是个数组，包含10个指针，每个指针指向XXX
		·处理外部(), (* test[10])() test是个数组，包含10个指针，每个指针指向一个XXX函数
		·char *(* test[10])(int p)    test个数组，包含10个指针，每个指针指向一个函数，函数有一个int参数和一个char *的返回值

	2.char (*(*x())[])()
		-声明一个数据类型：x
		-x被()包围，先处理()内部。
		-x() x是个函数
		-*x() x是个函数，函数返回值是个指针，指向的数据类型不明，可以typedef char (*(y))[])() 	;所以此时x()返回值是一个指向y类型的指针。即y * x();
		--此时看char (*(y)[])() 
		-y紧跟[]，y是个数组，
		-*y[]，y是个数组，数组元素为指针，指针类型不确定，可以typedef char (*z)();
			所以此时等于 z * y[]; y的数组元素是指针，指向z数据类型。
		--此时看char (*z)()，z是个指针函数，

		综上：x是一个函数，返回指针，指向一个数组，数组元素为char *类型的函数指针




		




