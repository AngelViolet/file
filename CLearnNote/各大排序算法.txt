十大排序算法  https://www.cnblogs.com/onepixel/articles/7674659.html

一.插入排序 https://blog.csdn.net/qq_37623612/article/details/80312121 (有复杂度计算)
	原数组为a[n] 	在输入规模大于1000的场合下不建议使用插入排序
	1.数组a中第一个数已经有序。
	2.数组a中第二个数和第一个比，然后排序。
	...
	3.数组a中第i个数和之前的i-1个数依次比，比它大，前面的这个数就往后挪一位。直到找到第一个比它小的，放其后。
	4.直到a的最后一个数a[n-1]和之前的数比较，找到第一个比它小的放其后。

	时间复杂度
	最好情况：o(n)	只比较（C），不移动（M），且每次for循环都只比较一次就进入下一次循环。
	最差情况：o(n^2)	比较i次，移动i+2次。∑(i) + ∑(i+2)  0=<i<n 

	空间复杂度：只占用了i,j,tmp三个辅助元素，所以空间复杂度为O(1)

二.希尔排序	https://blog.csdn.net/sinan1995/article/details/81095582
	原数组a[n]		
	1.确定初始增量gap = n/2，若gap》=1，gap/=2
	2.根据gap把a分组，循环取出每一组（i++）的第一个数i=0（i<gap），以gap为间隔为组员
	3.以gap为增量的小组确定后，对每一小组采用插入排序（插入排序又会有两次循环）
	共计四次循环
	网上有一种方案，只有三次循环。
	for1：确定分组gap，与上面第一次循环一致
	for2：从gap位置开始，到n （i = gap，i < n;i++）
	for3：开始比较 j=i-gap,j>=0;j-=gap。
		这样一来不是进行每一组的比较。而是进行所有组里的共同第几个数来比。
		先第一组第二个数比较改组第一个数，然后第二组第二个数比较改组第一个数...最后一组第二个数，比较改组第一个数。此时i到了gap+gap的位置。及第三个数的位置。
		然后继续和a[j]比较。
		直到i=n-1.完成了最后一组最后一个数和改组前面所有的数比较。

	如此就会省去一个循环。


	时间复杂度：
	最好情况：O(n)，只比较，不移动。
	最坏情况：O(n^2)
	平均情况：O(n^1.3)

	空间复杂度：O(1）

	在十万级别的数据上测试。希尔排序大概在0.05秒。插入排序用了6.5s shell排序用了0.035s


三.冒泡排序	找到最大的放在后面。
数组a[n]
1.从首位数开始和二位的数比较，首位大就交换。
2.从二位和三位比较，二位大就交换。
3.持续到第n-1和第n个数，谁大谁放后面。
4.end=n-1；重复上面操作，持续到end=1。

	时间复杂度
	最好情况：O(n)  只比较，不移动
	最坏情况：O(2*n^2)

	10万级数据排序时间在1分09秒

四：地精排序	找到当前位置的数在此前所有数中比他小的数，放在其后。然后从放完后的位置开始。向前冒泡
	数组a[n],借用i元素
1.先i=0。然后判断游标是否退回到0，或者a[i] >= a[i-1] ，游标自增i++
2.游标不为0，并且a[i] < a[i-1] ,游标自减 i--
3.当i=n的时候，停止循环。

	时间复杂度
	最好情况：O(n)  只比较，不移动
	最坏情况：O(n^2)

	10万级数据排序时间在43秒。

五：快速排序 找第一个数为key，将数组分为左小右大两部分。继续对分后的组继续如此操作。
	数组a[n]
1.取传入来的数组值的第一个值，key = a[left]
2.分成两组：
	方案1：遍历数组，大于key的值放左边，小于的放右边。
	2.1 从i=left+1开始和key比。j=left.遇到第一个比key小的，,j++,swap(a[i],a[j]);
	2.2 继续遍历，直至结束
	2.3 交换a[left] a[j-1]的值

	方案2：百度百科。i=left，j=right，while(i<j)时
	1.在j始终大于i的前提开始递减j--，找到第一个比key小的下标，swap(a[i],a[j])
	2.此时依旧在i小于j的前提下递增i++，找到第一个比key大的下标，swap(a[j],a[i])
	3.i，j经过一轮递变,再次进入循环判断。

	两种方案效率无差。
	
3.将分后的左组递归调用一次，右组递归调用一次。

时间复杂度：
	最好情况：O(nlog2n)
	最坏情况：O(n^2)
	平均情况：O(nlog2n)
空间复杂度：O(nlog2n)

	10万级数据用时大概在0.02秒