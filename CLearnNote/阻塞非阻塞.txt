https://www.cnblogs.com/h2zZhou/p/7283714.html

1.形象描述。
	你有数个同学来访 <---> 有若干数据需要收取
　你时不时的去门口看看，没有看到你同学的话就回客厅等待，看到同学就接到客厅来 <---> 非阻塞模式，无论收到数据与否都返回
	你一直在门口等着你同学，接到后才回客厅 <---> 阻塞模式，接收到数据后才返回
	
2.套接字有两种模式，阻塞模式与非阻塞模式。默认创建的为阻塞模式.
	2.1在blocking model 下：
	套接字在IO时阻塞应用程序，就是说控制权不会返回给应用程序，也就是说程序执行到此代码时会卡住。分两种情况:
		1.send函数时,只有把要发送的数据下传至TCP层，send这句代码才继续向下执行，此时可确认自己的数据已经在网络上传输了
		2.recv时，只有收到一定数据给应用程序缓冲区时,recv这行代码才会向下执行。
	如果不想这样做，可以使用多线程，或者选用其他网络IO模型。一般在做服务器程序时，不会使用阻塞套接字，性能低，数据吞吐率也不高。优点是此种模型编写难度较低，可以用来做入门的学习之用。
	
	2.2非阻塞套接字.
	IO会马上返回.即:
		send函数会把数据直接发送到SOCKET缓冲区，然后执行send后的代码。从缓冲区再发送到TCP层。
		recv函数会从SOCKET缓冲区里读取数据，不管有没有读到都执行下一行。
	但在send时，如果SOCKET缓冲区已满，会返回错误，使用WSAGetLastError会得到错误码为WSAEWOULDBLOCK,意思是说在一个非阻塞的套接字上，请求没有完成。recv时如果SOCKET缓冲区没有可以读的数据，也会返回WSAEWOULDBLOCK.
	
3.默认阻塞，设置为非阻塞。

https://www.cnblogs.com/sunziying/p/6501045.html

阻塞socket和非阻塞socket
建立连接
阻塞方式下，connect首先发送SYN请求道服务器，当客户端收到服务器返回的SYN的确认时，则connect返回.否则的话一直阻塞.
非阻塞方式，connect将启用TCP协议的三次握手，但是connect函数并不等待连接建立好才返回，而是立即返回。返回的错误码为EINPROGRESS,表示正在进行某种过程.      

接收连接
对于阻塞方式的倾听socket,accept在连接队列中没有建立好的连接时将阻塞，直到有可用的连接，才返回。
非阻塞倾听socket,在有没有连接时都立即返回，没有连接时，返回的错误码为EWOULDBLOCK,表示本来应该阻塞。


4.对于非阻塞是指套接字fd的属性设置为非阻塞模式，
	int32_t nOldOpt = fcntl(nSockFd, F_GETFL);  //获取文件状态标志
    int32_t nNewOpt = nOldOpt | O_NONBLOCK;     

    fcntl(nSockFd, F_SETFL, nNewOpt);           //设置文件状态标志
    https://www.jianshu.com/p/504a53c30c17   linux的文件描述符和文件
   在linux内核中通常会有个task_struct结构体来维护进程相关的表，叫进程控制块，这个块里面会有指针指向file_struct的结构体，称为文件描述表，文件描述符就是这个表的索引。
   	所以上述函数对一个int型的FD进行的操作实际上就是对文件描述表里的属性进行的变动。而进行recv,send时，也是通过控制文件描述表实现的












































