mapper.java与service为接口，
serviceImpl为实现。
mapper.xml为映射文件。

java的三大属性：封装、继承、多态。
javadoc  API帮助文档。javadoc -d myhelp -author -version MainDemo.java。
	MainDemo.java中的类必须被public。
	MainDemo.java中的方法只有被public或者protect的才会显示在文档中。

1.类：	对现实生活中事物的描述。
		每个类（事物）都具有自己的属性和功能。
		定义类，就是在描述事物，就是在定义属性和功能（行为）。
		属性和行为共同称为类中的成员（即成员变量和成员函数）。
		类定义的变量称之为：类类型变量。类类型变量指向对象。

		Person p = new Person();
			Person p 只是在栈中，定义了一个Person大小的变量空间。
			new Person()才开始利用构造函数加载类，先找到Person.class文件加载到内存中。
	
2.对象：这类食物对应的真实个体。
	Car c = new Car();		在栈中有一个变量C，指向堆中申请的地址0x02a2，该地址0x02a2保存Car类具有的属性。

3.乐观锁和悲观锁		http://www.cnblogs.com/sheseido/p/5038562.html
	3.1：悲观锁：每次去获取数据时，都认为其他人会对数据修改，所以获取时立刻锁上。这样别人拿数据时就会被block。
		可以减少并发问题。但是当并发量很大的时候，锁会多，导致消耗更多的资源。锁定时间较长会影响系统性能。
	3.2：乐观锁：总认为不会有并发问题，每次读取数据时并不上锁，但是会对version或CAS方式来判断数据是否被其他人更新。
4.构造函数
	4.1：与类名一致
	4.2：不具有返回值类型
	4.3：具有给对象初始化的功能。
	4.4: 每个类都有自己的构造函数。未在类中自定义构造函数，系统默认提供空初始化的构造函数：Person(){}；
	4.5：构造函数可以重载，用于不同的初始化。
	4.6：构造函数在对象建立时运行，且只运行这一次。一般函数在调用时执行，可多次执行。
	4.7：分析事物时，在事物存在时就具有一些行为或功能，就需要定义构造函数
	4.8：在构造函数执行之前，会先执行构造代码块。同样只执行一次，对所有重载的构造函数相同的属性就行初始化。
		构造代码块是一块代码区域集合，不具有名字。不定义时，默认也是空的{}.

5.this关键字
	5.1：用于区分成员变量和局部变量。
	5.2：代表所在函数所属对象的引用。
	5.3：对成员引用时，系统都是默认隐藏了this.。
	5.4：构造函数间的函数调用，需要用this。注意，不是this.
			Person(int a);
			Person(int a, String n){ this(age); this.name = n;  }
		注意：this语句在构造函数间的调用时，只能用于第一行。
			  避免出现死循环，即第一个构造函数不要用this


6.static 关键字
	6.1：修饰符，用于修饰成员（变量和函数）。
	6.2：对于重复的数据（共同数据），可用static修饰，进行单独空间的存储，减少内存消耗。static修饰的成员不在堆内存中。
			因为不在堆中，即不是new对象时创建的空间。所以被对象所共享。
		如  class student
			{
				String 电脑;
				static String 饮水机;
				string 杯子；
			}
			电脑每个人都需要，所以在创建对象时，在堆中申请一个电脑。
			饮水机可以共有。所以不放在每个对象的堆内存中。
			杯子不能共有，放在堆中。
			如果static String 饮水机; -》  String 饮水机;则每个人都有一个饮水机，浪费资源。
	6.2：当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用，还可以直接被类名调用。
	6.3：static的特点
		1.随着类的加载而加载，随着类的消失而消失。生命周期最长。
		2.优先于对象存在。
		3.被所有对象所共享。
		4.可以直接被类名所调用。

		class Person
		{
			int age;//成员变量or实例变量。对象在，它在，对象不在，他不在。
			static String country = "cn";// 静态变量。类在，它在，类不在，它不在。
		}

	6.4：类变量和实例变量。
		1.存放位置
			类变量随着类的加载而存放在方法区中。
			实例变量随着对象的建立存放在堆内存中。
		2.生命周期
			类变量生命周期和类相同。
			实例变量生命周期与对象一直。

	6.5：使用static的注意事项
		1.静态方法只能访问静态成员。非静态方法可以访问静态与非静态成员。
		2.静态方法中不可以出现this、super关键字。

	6.6：静态变量(类变量)的使用前提


7.主函数的定义
public：访问权限最大。
static：代表主函数随着类的加载就已经存在了。
void：没有具体的返回值。main执行完后，虚拟机不需要任何值了。
main:不是关键字，是一个特殊的单词，可以被jvm识别。
String[] args：参数是一个字符串类数组。
jvm在调用主函数的时候，传入的是 new String[o];


8.工具类  														class Tool{
8.1：没有成员变量，只有成员函数。										private Tool();
8.2：所有的类方法都是被static修饰，可通过类名直接调用。					public static int getMax(int[] arr){...}
8.3：强制该类不可以被建立对象，只用来调用方法，所以要构造函数私有化。	}


9.静态代码块																class StaticCode
随着类的加载而执行，只执行一次，并优先于主函数执行							{
用于给类进行初始化															static
																			{
																				System.out.println("static code");
																			}
																		}


10.总结：静态代码块、静态成员函数、构造代码块、构造函数的执行顺序。以及构造函数是否可以被静态---不可以。

11.对象初始化的顺序，创建对象后： Person p = new Person("angel", 20);
 	1.new Person("angel", 20)会先找到Person,class，加载到内存中。
 	2.执行该类中的static代码块。
 	3.在堆内存中开辟空间，分配内存地址。p将会->该地址
 	4.在堆存中建立对象的特有属性，并进行默认初始化（或者说显示初始化的值为NULL和0）。
	5.构造代码块初始化
	6.构造函数初始话。
	7.将类地址复制给p。

12.设计模式--java中共有23中设计模式。
1.单例设计模式：解决一个类在内存中只存在一个对象。
	1.1.构造函数私有化---防止其他程序建立该类对象。
	1.2.在本类中建立一个对象---因其他地方无法建立该类对象，所以需要在本类中建立一个。
	1.3.在本类中定义一个接口用于访问该对象。
	1.4.该类事物的描述不变，只是加上以上三步，对象就会唯一。
	1.5.使用时多为饿汉式，面试时多问懒汉式（设计锁、多线程，需要双重判断，见day06-10）,锁synchronized的调用占用内存。

13.继承 extends  
	1.子类中，本类对象用this,父类 ！同名！  对象用super	
	2.子类和父类出现相同的函数，通过子类对象调用该函数时，父类的函数会被子类覆盖。---子类继承的父类中，有该类功能但内容不同。
	3.子类中函数的权限不能低于父类，不然不能覆盖。(权限默认为protect)
	4.子类的构造函数第一行有一个默认的隐式父类构造函数：super(); 即每次加载子类的构造函数前都会先加载父类的构造函数。
		Zi(){	//super();	}
	   如果父类中构造函数被重载，即父类中没有Fu(){},而是Fu(int x){};,此时在子类的构造函数中需要手动分配父类的构造函数。
	   	class Fu{ Fu(int x){}  }	

	   	class Zi extends Fu{ Zi(){ super(2); } }

注：
	   子类中所有构造函数默认都会访问父类中空参数的构造函数。
	   因为每一个子类的构造函数内的第一行都有一个隐式的super();
	   当父类中没有空参数的构造函数时，子类的构造函数中必须通过super或者this语句形式来制定访问父类中
	   子类的构造函数中第一行可以通过this语句就是调用本类的其他构造函数，故本类中至少有一个构造函数直接访问父类的构造函数。
	   this和super不能再同一个构造函数中，因为这俩都是需要在第一行的，在第一行是由于要先进行初始化动作。

14.final关键字
	1.修饰类、函数、变量。
	2.被final修饰的类不可以被继承，为了避免因继承导致子类复写功能。
	3.被final修饰的方法不可以被复写。
	4.被final修饰的变量是一个常量，只能被赋值一次。即可以修饰成员变量，又可以修饰局部变量
		当描述事物时，一些数据的值是固定的，为了增强阅读性，都给这些值起个名字，一半为大写（类似于宏定义）



15.抽象类---抽象==看不懂，看不见。	
	当多个类中出现相同的功能，但是功能主体不一样。这时可以向上抽取，只抽取功能定义，不抽取功能主体。
	特点：
	1.抽象方法一定在抽象类中，
	2.抽象方法和抽象类都要被abstract关键字修饰
	3.抽象类不可以用于new创建对象，因为调用抽象方法没有意义。
	4.抽象类中的方法要被使用，必须由子类复写所有的抽象方法，建立子类对象调用。如果该子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。
	5.抽象类中可以有非抽象方法，即比一般类多了抽象函数，就是在类中可以定义抽象方法。（或者说，一个类中如果有一个抽象方法，就必须修饰为抽象类，但是类被abstract修饰为抽象类后，可以不定义抽象方法，用于强制禁止该类定义对象。）


16.接口:如果抽象类中的方法全部都是抽象的，那么该类可以通过接口的形式来表示。
	1.接口常见定义：变量，抽象方法
	2.接口成员都有固定的修饰符(都是public的)，如未写明，系统会默认public static final ,punlic abstract	
		常量：public static final
		方法：public abstract
	3.接口可以被一个类多实现，也是对多继承不支持的弥补。 ？？多实现是什么。
	4.接口间可以继承，可以多继承：interface A{}, interface B{}, interface C extends A,B{}
		注意，接口多继承时，A和B中不可以有相同名称不同返回值的方法。只有接口才有多继承。
	5.接口用于拓展类的一些其他功能，但不是类一定具有的功能（即类体系外的功能）。


day08
17.多态：事物存在的多种体现形态。对象的多态性。
	1.代码体现：父类的引用（Animal a）可以指向（=）子类对象（new Cat();）
	2.好处：提升代码的拓展性。
	3.前提：必须是类与类之间有关系，要么继承，要么实现。 
	4.多态的向上转型（类型转换）转成父类型
		Animal a = new Cat();					
	 向下转型（强制转换）
	 	Cat c = (Cat)a;
	 注意 不允许：
	 	Animal a = new Animal();
	 	Cat c = (Cat)a;
	 综上：父类引用可以指向子类对象，此时该引用可以被提升和强制转换。
	 	   父类的对象不可以转成子类的引用。
	 	   多态自始至终都是子类对象在变换。	
	 5.instanceof 关键字：判断引用是不是该类型：  if(a instanceof Cat)
	 6.在多态中：成员函数（非静态）的调用：编译看左边，运行看右边。
	 			成员变量和静态变量的调用：都是靠看左边。


18.Object类:所有对象的父类，是根类。
	1.equals（）方法：类的比较，比较的是类引用的地址。
	2.toString()方法。类转成字符串。类名+@+哈希值


day09

19.内部类
	1.访问规则：内部类可以直接访问外部类成员，包括私有。
		访问外部类成员：外部类名.this.成员变量名
		外部类访问内部类，也要先建立内部类对象。
	2.当内部类定义在外部类的成员位置上，且非私有。在外部其他类中，可以直接建立内部类对象。
		格式：Outer.Inner in = new Outer().new Inner();
	  当内部类在成员位置上，就可以被成员修饰符所修饰，如static，private。
	  内部类中有静态成员，必须为静态内部类。
	  内部类定义在局部变量中，不可以被静态或者私有。

20.try catch 异常
	


































